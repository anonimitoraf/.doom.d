#+TITLE: Languages

* Clojure/script
Allow LSP to auto-insert namespaces
#+begin_src elisp :results none
(use-package clojure-mode
  :config
  (setq cljr-add-ns-to-blank-clj-files nil))
#+end_src

Formatting
#+begin_src elisp :results none
(use-package apheleia
  :config
  (setf (alist-get 'zprint apheleia-formatters)
        `("zprint"
          ,(concat
             "{:style [:respect-nl :justified]"
             " :map {:comma? false "
             "       :justify {:max-variance 64, :no-justify nil}"
             " }"
             " :binding {:justify {:max-variance 64}"
             " }"
             " :pair {:justify {:max-variance 32}"
             " }"
             "}"
             )))
  (add-to-list 'apheleia-mode-alist '(clojure-mode . zprint))
  (add-to-list 'apheleia-mode-alist '(clojurescript-mode . zprint))
  (add-to-list 'apheleia-mode-alist '(clojurec-mode . zprint)))
#+end_src

Nice offline docs
#+begin_src elisp
(add-to-list 'dash-docs-docsets "Clojure")
#+end_src

Font lock "hacks". TODO Find out how to do these properly
#+begin_src elisp
(add-hook 'clojure-mode-hook
          '(lambda ()
             ;; Set some new syntax-highlighting rules.
             ;; Guardrail's >defn
             ;; Highlight particular macros similar to built-in stuff
             ;; For example, highlight ghostwheel's `>defn' similar
             ;; the same way as built-in `defn'
             (font-lock-add-keywords nil
                                     ;; So many escape codes! But we're really just saying:
                                     ;; Match the '(' character.
                                     ;; Match and group the string '>defn'.
                                     ;; Match some whitespace. \\s-+
                                     ;; Match and group some word characters. \\w+
                                     '(("(\\(>defn\\)\\s-+\\(\\w+\\)"
                                        ;; The first regexp group is a keyword.
                                        (1 font-lock-keyword-face)
                                        ;; The second regexp group is a name.
                                        (2 font-lock-function-name-face))))
             (put '>defn 'clojure-doc-string-elt 2)))
#+end_src

Popup rules
#+begin_src elisp
(set-popup-rules!
  '(("^\\*cider-repl"
     :quit nil
     :side right
     :size 0.33
     :select t
     :modeline t)
    ("^\\*\\(?:cider-doc\\)"
     :side bottom
     :size 0.2)))
#+end_src

Pretty-printing currently selected Clojure code with =jet=
#+begin_src elisp
(defun ++clojure-pretty-format ()
  (interactive)
  (shell-command-on-region
   (region-beginning)
   (region-end)
   "jet --pretty --edn-reader-opts '{:default tagged-literal}'"
   (current-buffer)
   t
   "*jet error buffer*"
   t))
#+end_src

JSON -> EDN with =jet=
#+begin_src elisp
;; TODO Instead of replacing buffer contents, copy to clipboard
(defun ++clojure-json->edn ()
  (interactive)
  (shell-command-on-region
   (region-beginning)
   (region-end)
   (concat "jet"
           " --pretty"
           " --edn-reader-opts '{:default tagged-literal}'"
           " --from json"
           " --to edn"
           " --keywordize '#(-> % csk/->kebab-case keyword)'")
   (current-buffer)
   t
   "*jet error buffer*"
   t))
#+end_src
* Erlang
Function for compiling, generating then visiting TAGS
#+begin_src elisp
(defun ++erlang-compile ()
  (interactive)
  (erlang-compile)
  (set-buffer "*erlang*")
  (let ((root (projectile-project-root)))
    (++async-shell-command
     (format (concat
              "find %s -type f -name \"*.[he]rl\" | etags.emacs"
              " -o " (concat root "TAGS")
              " -")
             root)
     (lambda (_) (progn (message (concat "Generated tags for project " root))
                        (visit-tags-table root))))))

#+end_src
Company is a bit useless inside the erlang-shell
#+begin_src elisp
(add-hook 'erlang-shell-mode-hook (lambda () (company-mode -1)))
#+end_src

#+begin_src elisp
(map! :map erlang-shell-mode-map
      "C-SPC" #'erlang-complete-tag
      "C-l" 'comint-clear-buffer)

(map! :map erlang-mode-map
      "C-c C-k" #'++erlang-compile)
#+end_src
* Type/Javascript
#+begin_src elisp
(use-package! gherkin-mode
  :config (add-to-list 'auto-mode-alist '("\\.feature\\'" . gherkin-mode)))
#+end_src

Auto-configure modes
#+begin_src elisp
(define-derived-mode typescript-tsx-mode web-mode "TypeScript/TSX")

(add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-tsx-mode))
#+end_src
* CSS family

#+begin_src elisp :results none
(use-package! lsp-mode
  :config
  (add-to-list 'lsp-language-id-configuration
    '(typescript-tsx-mode . "css-modules"))
  (lsp-register-client
    (make-lsp-client :new-connection (lsp-stdio-connection "cssmodules-language-server")
                     :priority -1
                     :add-on? t
                     :activation-fn (lsp-activate-on "css-modules")
                     :server-id 'css-modules)))
#+end_src

Use CSS comments for SASS since I'm using CSS tree-sitter for highlighting
#+begin_src elisp :results none
(add-hook 'scss-mode-hook (lambda ()
                            (setq-local comment-start "/* "
                                        comment-end " */")))
#+end_src

* Groovy
#+begin_src elisp
(use-package! lsp-mode
    :hook (groovy-mode . lsp-deferred)
    :commands (lsp lsp-deferred)
    :config (setq lsp-groovy-classpath
              ["/usr/local/opt/groovy/libexec/lib"
                "~/.gradle/caches/modules-2/files-2.1"]))
#+end_src
* Prolog
#+begin_src elisp :results none
(add-to-list 'auto-mode-alist '("\\.pl$" . prolog-mode))
#+end_src

#+begin_src elisp :results none
(use-package! lsp-mode
  :hook (prolog-mode . lsp)
  :config
  (lsp-register-client
   (make-lsp-client
    :new-connection
    (lsp-stdio-connection (list "swipl"
                                "-g" "use_module(library(lsp_server))."
                                "-g" "lsp_server:main"
                                "-t" "halt"
                                "--" "stdio"))
    :major-modes '(prolog-mode)
    :priority 1
    :multi-root t
    :server-id 'prolog-ls)))
#+end_src
