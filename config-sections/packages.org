#+TITLE: Packages
#+STARTUP: overview
* =ace-window=
#+begin_src elisp
(map! :map doom-leader-map "w SPC" #'ace-select-window)
#+end_src
Make window labels very obvious
#+begin_src elisp
  (custom-set-faces!
    '(aw-leading-char-face
      :foreground "white" :background "red"
      :weight bold :height 2.5 :box (:line-width 10 :color "red")))
#+end_src
* =alert=
#+begin_src elisp :results none
(require 'alert)
(setq alert-default-style (if IS-MAC
                            'growl
                            'dunst+i3)
      alert-fade-time 120)
#+end_src
* =all-the-icons=
They're too big (by default) for my taste
#+begin_src elisp
(use-package! all-the-icons
  :config (setq all-the-icons-scale-factor 0.90))
#+end_src
* =apheleia=
#+begin_src elisp :results none
(use-package apheleia
  :config
  (apheleia-global-mode t))
#+end_src
* =avy=
This package is used for jumping around efficiently within a file. I really ought to use it more.

Searching should be done using 2 chars almost all the time hence we use a very short timeout.
#+begin_src elisp
(setq avy-timeout-seconds 0.1)
#+end_src
* =built-ins=
** bookmarks
I want to sync bookmarks across my devices.
#+begin_src elisp
(setq bookmark-default-file (concat ++sync-folder-path "/bookmarks"))
#+end_src

Save bookmarks immediately (rather than just when Emacs is killed).
#+begin_src elisp
(setq bookmark-save-flag 1)
#+end_src
** replace
#+begin_src elisp
(map! :leader
      :desc "Find-replace" "r" #'anzu-query-replace)
(map! :leader
      :desc "Find-replace (regexp)" "R" #'anzu-query-replace-regexp)
#+end_src
* =cider=
#+begin_src elisp
(use-package! cider
  :config
  (setq cider-repl-pop-to-buffer-on-connect nil
        cider-dynamic-indentation nil
        cider-font-lock-dynamically nil
        cider-font-lock-reader-conditionals nil
        nrepl-force-ssh-for-remote-hosts t)
  (map! :map cider-inspector-mode-map
        :nv "C-k" #'cider-inspector-previous-inspectable-object
        :nv "C-j" #'cider-inspector-next-inspectable-object
        :nv "C-h" #'cider-inspector-pop
        :nv [mouse-3] #'cider-inspector-pop
        :nv "C-l" #'cider-inspector-operate-on-point)
  (add-hook 'cider-mode-hook (lambda () (setq-local completion-styles '(cider)))))
#+end_src

Free up the minibuffer by not showing CIDER docs there
#+begin_src elisp
(advice-add 'cider-eldoc :around #'ignore)
#+end_src

Patch for being able to connect to multiple nREPL instances by using a random local port each time
#+begin_src elisp
;; (defun nrepl--ssh-tunnel-connect (host port)
;;   "Connect to a remote machine identified by HOST and PORT through SSH tunnel."
;;   (message "[nREPL] Establishing SSH tunneled connection to %s:%s ..." host port)
;;   (let* ((remote-dir (if host (format "/ssh:%s:" host) default-directory))
;;          (local-port (nrepl--random-free-local-port))
;;          (ssh (or (executable-find "ssh")
;;                   (error "[nREPL] Cannot locate 'ssh' executable")))
;;          (cmd (nrepl--ssh-tunnel-command ssh remote-dir port local-port))
;;          (tunnel-buf (nrepl-tunnel-buffer-name
;;                       `((:host ,host) (:port ,port))))
;;          (tunnel (start-process-shell-command "nrepl-tunnel" tunnel-buf cmd)))
;;     (process-put tunnel :waiting-for-port t)
;;     (set-process-filter tunnel (nrepl--ssh-tunnel-filter local-port))
;;     (while (and (process-live-p tunnel)
;;                 (process-get tunnel :waiting-for-port))
;;       (accept-process-output nil 0.005))
;;     (if (not (process-live-p tunnel))
;;         (error "[nREPL] SSH port forwarding failed.  Check the '%s' buffer" tunnel-buf)
;;       (message "[nREPL] SSH port forwarding established to localhost:%s" local-port)
;;       (let ((endpoint (nrepl--direct-connect "localhost" local-port)))
;;         (thread-first endpoint
;;           (plist-put :tunnel tunnel)
;;           (plist-put :remote-host host))))))

;; (defun nrepl--random-free-local-port ()
;;   (let* ((random-free-local-port-cmd (concat "comm -23 "
;;                                              "<(seq 1024 65535 | sort) "
;;                                              "<(ss -Htan | awk '{print $4}' | cut -d':' -f2 | sort -u) | "
;;                                              "shuf | head -n 1")))
;;     (with-temp-buffer
;;            (insert (string-trim-right (shell-command-to-string random-free-local-port-cmd)))
;;            (buffer-string))))

;; (defun nrepl--ssh-tunnel-command (ssh dir remote-port local-port)
;;   "Command string to open SSH tunnel to the host associated with DIR's PORT."
;;   (with-parsed-tramp-file-name dir v
;;      ;; this abuses the -v option for ssh to get output when the port
;;     ;; forwarding is set up, which is used to synchronise on, so that
;;     ;; the port forwarding is up when we try to connect.
;;     (format-spec
;;      "%s -v -N -L %l:localhost:%p %u'%h'"
;;      `((?s . ,ssh)
;;        (?l . ,local-port)
;;        (?p . ,remote-port)
;;        (?h . ,v-host)
;;        (?u . ,(if v-user (format "-l '%s' " v-user) ""))))))
#+end_src

#+begin_src elisp :results none
(add-to-list 'auto-mode-alist '("\\*cider-error\\*" . cider-stacktrace-mode))
#+end_src

#+begin_src elisp :results none
(defun cider--client-tramp-filename (name &optional buffer)
  "Return the tramp filename for path NAME relative to BUFFER.
If BUFFER has a tramp prefix, it will be added as a prefix to NAME.
If the resulting path is an existing tramp file, it returns the path,
otherwise, nil."
  (let* ((buffer (or buffer (current-buffer)))
         (name (replace-regexp-in-string "^file:" "" name))
         (name (concat (cider-tramp-prefix buffer) name)))
    (if (and (tramp-tramp-file-p name)
             (tramp-handle-file-exists-p name))
        name)))
#+end_src

Auto-kill bufffer when CIDER disconnects
#+begin_src elisp :results none
(defun ++kill-disconnected-cider-buffer (process _message)
  (when-let* ((client-buffer (process-buffer process)))
    (kill-buffer client-buffer)))

(advice-add #'nrepl-client-sentinel :after #'++kill-disconnected-cider-buffer)
#+end_src
* =clipetty=
#+begin_src elisp
(use-package! clipetty
  :config
  (unless (display-graphic-p)
    (global-clipetty-mode +1)))
#+end_src
* =clippo=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! clippo)
#+end_src
* =consult=
#+begin_src elisp :results none
(use-package! consult
  :config
  (consult-customize
    consult-ripgrep consult-git-grep consult-grep
    consult-bookmark consult-xref
    consult--source-bookmark
    +default/search-project
    +default/search-cwd
    +default/search-other-cwd
    :preview-key '(:debounce 0.2 any))
  (map! :map doom-leader-map
        "y" #'consult-yank-from-kill-ring))
#+end_src
* =drag-stuff=
#+begin_src elisp :results none
(map! :map global-map
  "C-S-k" #'drag-stuff-up
  "C-S-j" #'drag-stuff-down)
#+end_src
* =dotenv-mode=
#+begin_src elisp
(use-package! dotenv-mode
  :config (add-to-list 'auto-mode-alist '("\\.env\\..*" . dotenv-mode)))
#+end_src
* =evil=
#+begin_src elisp
(define-key evil-insert-state-map (kbd "C-j") nil)
(define-key evil-insert-state-map (kbd "C-k") nil)
(define-key evil-motion-state-map (kbd "<tab>") nil)

(define-key evil-motion-state-map (kbd "C-o") 'evil-jump-backward)
(define-key evil-motion-state-map (kbd "C-i") 'evil-jump-forward)
#+end_src

Configure particular commands to register a jump (i.e. my most used navigation commands)
#+begin_src elisp :results none
(evil-add-command-properties #'projectile-find-file :jump t)
(evil-add-command-properties #'find-file :jump t)
(evil-add-command-properties #'consult-recent-file :jump t)
(evil-add-command-properties #'doom/find-file-in-private-config :jump t)
(evil-add-command-properties #'+default/search-buffer :jump t)
#+end_src

Disable the annoying auto-comment on newline.
#+begin_src elisp
(setq +evil-want-o/O-to-continue-comments nil)
#+end_src

Unbind annoying key that I press a lot accidentally.
#+begin_src elisp
(unbind-key "K" evil-normal-state-map)
(unbind-key "K" evil-visual-state-map)
(unbind-key "K" evil-motion-state-map)
#+end_src

I've always found evil's undo to undo more than I want it to
#+begin_src elisp
(setq evil-want-fine-undo t)
#+end_src

I keep changing my mind about this, but for now, I think splitting and selecting the left and top windows feel better.
#+begin_src elisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

evil-collection with workaround for =slime= specifically (and evaluation of the last sexp)
#+begin_src elisp
(use-package! evil-collection
  :config
  (setq evil-collection-setup-minibuffer t))
#+end_src
** =evil-easymotion=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! evil-easymotion
  :config
  (unbind-key "s" evil-normal-state-map)
  (evilem-default-keybindings "s")
  (custom-set-faces!
    '(avy-lead-face :foreground "red" :background nil :weight bold)
    `(avy-lead-face-0 :foreground ,(doom-color 'yellow) :background nil)))
#+end_src
** =evil-matchit=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! evil-matchit
  :config
  (global-evil-matchit-mode +1))
#+end_src
* =elfeed=
#+begin_src elisp :results none
(use-package! elfeed
  :config
  (setq rmh-elfeed-org-files (list (concat doom-private-dir "elfeed.org"))
        elfeed-db-directory "~/Dropbox/emacs/elfeed")
  (add-hook 'elfeed-search-mode-hook (lambda ()
                                       (elfeed-update)
                                       (setq-local browse-url-browser-function 'eww-browse-url))))

(after! elfeed
  (setq elfeed-search-filter "@5-year-ago +unread"))
#+end_src
* =embark=
#+begin_src elisp :results none
(map! :map global-map
      "C-'" #'embark-act)
#+end_src
* =exercism=
#+begin_src elisp :results none
(map! :map global-map :nv "SPC o e" #'exercism)
#+end_src
* =exec-path-from-shell=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! exec-path-from-shell
  :config
  (exec-path-from-shell-copy-env "SSH_AGENT_PID")
  (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))
#+end_src
* =flycheck=
Emphasize the error/warning fringe indicators. When I go through a file, I typically rely on the fridge to tell guide me to code that I have to fix.
#+begin_src elisp
(define-fringe-bitmap 'flycheck-fringe-bitmap-beam
  (vector #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000
          #b11000000))

(flycheck-define-error-level 'error
  :severity 30
  :compilation-level 2
  :overlay-category 'flycheck-error-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-beam
  :fringe-face 'flycheck-fringe-error
  :error-list-face 'flycheck-error-list-error)

(flycheck-define-error-level 'warning
  :severity 20
  :compilation-level 2
  :overlay-category 'flycheck-warning-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-beam
  :fringe-face 'flycheck-fringe-warning
  :error-list-face 'flycheck-error-list-warning)

(flycheck-define-error-level 'info
  :severity 10
  :compilation-level 2
  :overlay-category 'flycheck-info-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-beam
  :fringe-face 'flycheck-fringe-info
  :error-list-face 'flycheck-error-list-warning)

(setq flycheck-display-errors-delay 0.01)
#+end_src

Popup-tip customization for the terminal
#+begin_src elisp
(use-package! flycheck-popup-tip
  :config
  (setq flycheck-popup-tip-error-prefix " "))
#+end_src

Customize the flycheck errors table to have longer columns and sort by error level by default
#+begin_src elisp
(use-package! flycheck
  :config
  (setq flycheck-error-list-format
        `[("File" 32)
          ("Line" 8 flycheck-error-list-entry-<)
          ("Col" 8 nil)
          ("Level" 32 flycheck-error-list-entry-level-<)
          ("ID" 32 t)
          (#("Message (Checker)" 0 7
             (face flycheck-error-list-error-message)
             9 16
             (face flycheck-error-list-checker-name))
           0 t)])
  (add-hook 'flycheck-error-list-mode-hook
            (lambda () (tabulated-list-sort 3)))
  (set-popup-rules!
    '(("*Flycheck errors*"
       :quit nil
       :side bottom
       :size 10
       :select nil))))
#+end_src

Make flycheck posframes a bit less obtrusive
#+begin_src elisp :results none
(use-package! flycheck-posframe
  :config
  (setq flycheck-posframe-position 'frame-bottom-left-corner))
#+end_src

Improve posframe appearance
#+begin_src elisp :results none
(setq flycheck-posframe-info-prefix " "
      flycheck-posframe-warning-prefix " "
      flycheck-posframe-error-prefix " "
      flycheck-posframe-prefix " ")
#+end_src

* =google-translate=
#+begin_src elisp
(use-package! google-translate
  :config
  (map! :leader :desc "Google translate" "s a" #'google-translate-smooth-translate)
  (setq google-translate-translation-directions-alist
        '(("en" . "ja") ("ja" . "en")))
  ;; Workaround: see https://github.com/atykhonov/google-translate/issues/137
  (defun google-translate--search-tkk ()
    "Search TKK."
    (list 430675 2721866130)))
(use-package! google-translate-smooth-ui)
#+end_src
* =hackernews=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! hackernews)
#+end_src
* =keychain-environment=
#+begin_src elisp
(require 'keychain-environment)
(keychain-refresh-environment)
#+end_src
* =i3wm-config-mode=
#+begin_src elisp
(require 'i3wm-config-mode)
#+end_src
* =ielm=
Set a cool prompt and make it non-noisy (What does this even mean?)
#+begin_src elisp
(setq ielm-noisy nil
      ielm-prompt "λ> ")
#+end_src
* =itail=
#+begin_src elisp
(require 'itail)
#+end_src
* =ispell=
Fix the ispell dictionary.
#+begin_src elisp :results none
(setq ispell-dictionary "en"
      ispell-personal-dictionary (concat ++sync-folder-path "/spell/personal-dictionary.pws"))
#+end_src
* =lsp=
#+begin_src elisp :results none
(use-package! lsp-mode
  :config
  (setq lsp-completion-enable t
        lsp-idle-delay 0.1)
  (add-hook! '(typescript-tsx-mode-hook
               typescript-mode-hook
               web-mode-hook
               js-mode-hook
               js2-mode-hook)
             ;; Use `tide' for completions and formatting instead since LSP is too laggy
             (setq-local lsp-completion-enable t
                         lsp-completion-show-detail nil
                         lsp-typescript-format-enable nil)
             ;; (when (-contains? '(typescript-tsx-mode
             ;;                     typescript-mode
             ;;                     web-mode
             ;;                     js-mode
             ;;                     js2-mode)
             ;;                   major-mode)
             ;;   (setq-local completion-at-point-functions (mapcar #'cape-company-to-capf
             ;;                                                     (list #'company-tide))))
             )
  (set-popup-rules!
    '(("*lsp-help*"
       :quit t
       :side right
       :size 0.3
       :select t
       :modeline t))))

(after! lsp-mode
  (setq lsp-lens-enable t
        lsp-log-io nil
        lsp-use-plists t
        lsp-completion-no-cache nil
        lsp-completion-use-last-result nil
        lsp-headerline-breadcrumb-enable t
        lsp-headerline-breadcrumb-icons-enable nil
        lsp-headerline-breadcrumb-enable-diagnostics nil
        lsp-eldoc-enable-hover nil
        lsp-lens-place-position 'end-of-line
        lsp-enable-indentation t
        lsp-signature-auto-activate t
        lsp-signature-function 'lsp-signature-posframe
        lsp-signature-posframe-params '(:poshandler posframe-poshandler-point-bottom-left-corner-upward
                                        :height 10
                                        :width 120
                                        :border-width 1
                                        :min-width 120))
  (map! :map evil-normal-state-map
        "g t" #'lsp-find-type-definition
        "g D" #'lsp-find-implementation)

  (map! :map lsp-signature-mode-map
        "C-j" #'lsp-signature-next
        "C-k" #'lsp-signature-previous))
#+end_src
Directories to ignore for specific languages
#+begin_src elisp
(after! lsp-mode
  ;; Clojure(Script)
  (dolist (to-ignore '("[/\\\\]\\.clj-kondo$"
                       "[/\\\\]\\.shadow-cljs$"
                       "[/\\\\]resources$"))
    (add-to-list 'lsp-file-watch-ignored to-ignore)))
#+end_src
Typescript
#+begin_src elisp
(use-package! lsp-mode
  :config
  (setq lsp-clients-typescript-server-args '("--stdio" "--tsserver-log-file" "/dev/stderr")))
#+end_src
=(lsp)= seems to make opening files a lot more responsive than =(lsp-deferred)=
#+begin_src elisp :results none
(advice-add 'lsp-deferred :override #'lsp)
#+end_src

** =lsp-ui=
TODO Convert the `define-key` statements to use `map!`
#+begin_src elisp
(after! lsp-ui
  (define-key lsp-ui-peek-mode-map (kbd "j") 'lsp-ui-peek--select-next)
  (define-key lsp-ui-peek-mode-map (kbd "k") 'lsp-ui-peek--select-prev)
  (define-key lsp-ui-peek-mode-map (kbd "C-k") 'lsp-ui-peek--select-prev-file)
  (define-key lsp-ui-peek-mode-map (kbd "C-j") 'lsp-ui-peek--select-next-file)
  (define-key evil-normal-state-map (kbd "g f") 'lsp-ui-peek-find-references)
  (map! :map lsp-mode-map
        :nv "SPC c m" #'lsp-ui-imenu
        :nv "SPC d" #'lsp-ui-doc-glance)
  (map! :map lsp-ui-peek-mode-map
        "l" #'lsp-ui-peek--goto-xref
        "C-l" #'lsp-ui-peek--goto-xref-other-window)
  (setq lsp-ui-peek-fontify 'always
        lsp-ui-peek-list-width 100
        lsp-ui-peek-peek-height 40
        lsp-ui-peek-always-show nil

        ;; These can be brought up on-demand with SPC d
        lsp-ui-doc-enable nil
        ;; Prevents LSP peek to disappear when mouse touches it
        lsp-ui-doc-show-with-mouse nil
        lsp-ui-doc-include-signature t
        lsp-ui-doc-delay 0
        lsp-ui-doc-position (if (display-graphic-p) 'at-point 'top)
        lsp-ui-doc-max-width 120
        lsp-ui-doc-max-height 120
        lsp-ui-doc-header nil


        lsp-ui-imenu-enable t

        ;; This is just annoying, really
        lsp-ui-sideline-enable nil))
#+end_src
Display lsp-ui-peek in a childframe so that the whole screen is used despite multiple windows.

Only on GUI though since TTY doesn't support posframes :^(.

Copied from https://github.com/emacs-lsp/lsp-ui/issues/441.
#+begin_src elisp
(when (display-graphic-p)
  (defun lsp-ui-peek--peek-display (src1 src2)
    (-let* ((win-width (frame-width))
            (lsp-ui-peek-list-width (/ (frame-width) 2))
            (string (-some--> (-zip-fill "" src1 src2)
                      (--map (lsp-ui-peek--adjust win-width it) it)
                      (-map-indexed 'lsp-ui-peek--make-line it)
                      (-concat it (lsp-ui-peek--make-footer)))))
      (setq lsp-ui-peek--buffer (get-buffer-create " *lsp-peek--buffer*"))
      (posframe-show lsp-ui-peek--buffer
                     :string (mapconcat 'identity string "")
                     :min-width (truncate (/ (frame-width) 1.1))
                     :poshandler #'posframe-poshandler-frame-center
                     :border-color "white"
                     :border-width 1)))

  (defun lsp-ui-peek--peek-destroy ()
    (when (bufferp lsp-ui-peek--buffer)
      (posframe-delete lsp-ui-peek--buffer))
    (setq lsp-ui-peek--buffer nil
          lsp-ui-peek--last-xref nil)
    (set-window-start (get-buffer-window) lsp-ui-peek--win-start))

  (advice-add #'lsp-ui-peek--peek-new :override #'lsp-ui-peek--peek-display)
  (advice-add #'lsp-ui-peek--peek-hide :override #'lsp-ui-peek--peek-destroy))
#+end_src
* =modeline=
#+begin_src elisp
(after! doom-modeline
  (setq doom-modeline-buffer-file-name-style 'auto
        doom-modeline-height 0
        doom-modeline-major-mode-icon t
        doom-modeline-major-mode-color-icon t
        doom-modeline-buffer-modification-icon t
        doom-modeline-modal-icon nil
        doom-modeline-buffer-state-icon nil
        doom-modeline-enable-word-count nil
        doom-modeline-lsp nil))
(setq org-clock-mode-line-total 'current)
(setq display-time-default-load-average nil
      display-time-24hr-format t)
#+end_src

Display clock on modeline
#+begin_src elisp
(display-time-mode +1)
#+end_src

Customize =doom-modeline= more specifically
#+begin_src elisp :results none
(use-package! doom-modeline
  :config
  (doom-modeline-def-segment matches
    (let ((meta (concat (doom-modeline--macro-recording)
                        (doom-modeline--anzu))))
      (or meta "")))
  (doom-modeline-def-modeline 'main
    '(bar matches buffer-info repl lsp checker)
    '(buffer-position selection-info))
  (doom-modeline-def-modeline 'minimal
    '(bar matches buffer-info-simple)
    '(major-mode))
  (doom-modeline-def-modeline 'special
    '(bar matches buffer-info)
    '(window-number buffer-position selection-info))
  (doom-modeline-def-modeline 'project
    '(bar matches buffer-default-directory)
    '(window-number buffer-position selection-info))
  (doom-modeline-def-modeline 'dashboard
    '(bar matches buffer-default-directory-simple)
    '(window-number buffer-position selection-info))
  (doom-modeline-def-modeline 'vcs
    '(bar matches buffer-info-simple)
    '(window-number buffer-position selection-info))
  (doom-modeline-def-modeline 'info
    '(bar matches buffer-info)
    '(window-number info-nodes buffer-position selection-info))
  (doom-modeline-def-modeline 'media
    '(bar matches buffer-info)
    '(window-number media-info process))
  (doom-modeline-def-modeline 'message
    '(bar matches buffer-info-simple)
    '(window-number buffer-position selection-info))
  (doom-modeline-def-modeline 'pdf
    '(bar matches buffer-info)
    '(window-number pdf-pages process))
  (doom-modeline-def-modeline 'org-src
    '(bar matches buffer-info-simple lsp checker)
    '(buffer-position selection-info))
  (doom-modeline-def-modeline 'timemachine
    '(bar matches git-timemachine)
    '(buffer-position selection-info)))
#+end_src
* =org=
#+begin_src elisp :results none
(after! org
  (setq org-directory (concat ++sync-folder-path "/org")
        org-default-notes-file (concat org-directory "/notes/default.org")
        org-agenda-files (cl-map 'list (lambda (f) (concat org-directory "/" f))
                                 '("life"
                                   "work"
                                   "captures"
                                   "notes")))
  (setq org-agenda-span 14
        org-agenda-start-on-weekday nil
        org-agenda-start-day "-3d"
        org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-window-setup 'other-window
        org-ellipsis " ▾"
        org-export-with-section-numbers nil
        org-hide-emphasis-markers t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 0
        org-src-preserve-indentation nil
        org-startup-folded 'content
        org-cycle-separator-lines 2
        org-todo-keywords '((sequence "TODO(t)" "ONGOING(o)" "ON HOLD(h)" "|" "DONE(d)" "CANCELLED(c)")
                            (sequence "[ ](T)" "[-](O)" "[?](H)" "|" "[X](D)"))
        org-log-done 'time
        org-hide-leading-stars t
        org-superstar-headline-bullets-list '("•")
        org-superstar-cycle-headline-bullets 1
        org-superstar-special-todo-items 'hide
        org-superstar-item-bullet-alist '("-")
        org-tags-column -120
        org-image-actual-width nil
        ;; Don't log the time a task was rescheduled or redeadlined.
        org-log-redeadline nil
        org-log-reschedule nil
        ;; Prefer rescheduling to future dates and times
        org-read-date-prefer-future 'time))
#+end_src
Refresh org-agenda after rescheduling a task
#+begin_src elisp
(defun org-agenda-refresh ()
  "Refresh all `org-agenda' buffers."
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'org-agenda-mode)
        (org-agenda-maybe-redo)))))

(defadvice org-schedule (after refresh-agenda activate)
  "Refresh org-agenda."
  (org-agenda-refresh))
#+end_src
Save all org buffers automatically after particular commands
#+begin_src emacs-lisp :tangle yes :results none
(advice-add 'org-deadline       :after (++advice-lambda #'org-save-all-org-buffers))
(advice-add 'org-schedule       :after (++advice-lambda #'org-save-all-org-buffers))
(advice-add 'org-store-log-note :after (++advice-lambda #'org-save-all-org-buffers))
(advice-add 'org-todo           :after (++advice-lambda #'org-save-all-org-buffers))
#+end_src
Allow pasting images into org-mode
#+begin_src elisp
(use-package! org-download
  :config (setq org-download-method 'attach))
#+end_src
Allow drag-and-drop-ing to `dired`
#+begin_src elisp
(add-hook 'dired-mode-hook 'org-download-enable)
#+end_src
Avoid wrapping org-tables
#+begin_src elisp
(add-hook 'org-mode-hook (lambda () (visual-line-mode -1)))
#+end_src
Interpret ansi codes in Results section (source: https://emacs.stackexchange.com/a/63562)
#+begin_src elisp :results none
(defun ++org-babel-interpret-ansi ()
  (when-let ((beg (org-babel-where-is-src-block-result nil nil)))
    (save-excursion
      (goto-char beg)
      (when (looking-at org-babel-result-regexp)
        (let ((end (org-babel-result-end))
              (ansi-color-context-region nil))
          (ansi-color-apply-on-region beg end))))))
(add-hook 'org-babel-after-execute-hook #'++org-babel-interpret-ansi)
#+end_src
Collapse all headings except for this one
#+begin_src elisp :results none
(defun ++org-collapse-all-except-current ()
  (interactive)
  "Collapse all nodes except current"
  (if (save-excursion (end-of-line) (outline-invisible-p))
      (progn (org-show-entry) (show-children))
    (outline-back-to-heading)
    (unless (and (bolp) (org-on-heading-p))
      (org-up-heading-safe)
      (hide-subtree)
      (error "Boundary reached"))
    (org-overview)
    (org-reveal t)
    (org-show-entry)
    (recenter-top-bottom)
    (show-children)
    (recenter-top-bottom)))
(map! :map org-mode-map
      :nv "SPC m z" #'++org-collapse-all-except-current)
#+end_src
** =org-capture=
#+begin_src elisp
(after! org
  (setq org-capture-templates
    '(("t" "" entry (file "~/Dropbox/org/captures/tasks.org")
        "* TODO %?\n%U"
        :kill-buffer t)
       ("t" "Task" entry (file "~/Dropbox/org/captures/tasks.org")
         "* TODO %?\n%U"
         :kill-buffer t)
       ("e" "From emacs" entry (file "~/Dropbox/org/captures/from-emacs.org")
         "* %i\n%?"
         :empty-lines 1
         :kill-buffer t)
       ("c" "From clipboard" entry (file "~/Dropbox/org/captures/from-clipboard.org")
         "* %x\n%?"
         :empty-lines 1
         :kill-buffer t)
       ("s" "Shopping list" entry (file "~/Dropbox/org/captures/shopping-list.org")
         "* [ ] %?"
         :jump-to-captured t
         :empty-lines 1
         :kill-buffer t)
       ;; ("L" "Org protocol link")
       ;; ("Lh" "Link (headless)" entry (file "~/Dropbox/emacs/web-bookmarks.org")
       ;;    "* %:annotation\n  %U\n\n  %i"
       ;;    :prepend t
       ;;    :immediate-finish t
       ;;    :kill-buffer t)
       ("Li" "Link (interactive)" entry (file "~/Dropbox/emacs/web-bookmarks.org")
          "* %:annotation %U\n  %?"
          :prepend t))))
#+end_src
** =org-babel=
NodeJS - Make sure org-babel finds `node_modules`
#+begin_src elisp
(setenv "NODE_PATH"
        (concat
         (getenv "HOME") "/org/node_modules"  ":"
         (getenv "NODE_PATH")))
#+end_src
Clojure
#+begin_src elisp
(use-package! ob-clojure
  :init (require 'cider)
  :config (setq org-babel-clojure-backend 'cider))
#+end_src
General

TODO Find out why emacs-lisp is set to nil
#+begin_src elisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . nil)
   (Clojure . t)
   (Javascript . t)))
#+end_src
#+BEGIN_SRC elisp :results none
(after! org
  (setq org-babel-results-keyword "results")
  (custom-set-faces!
    `(org-level-1 :foreground ,(doom-color 'yellow))
    `(org-meta-line :foreground ,(doom-color 'grey))
    `(org-table :foreground ,(doom-color 'orange))
    `(org-block :background ,(doom-color 'black))
    `(org-block-begin-line :foreground ,(doom-color 'grey) :overline t)
    `(org-block-end-line :foreground ,(doom-color 'grey) :overline nil :underline t)
    `(org-code :foreground ,(doom-color 'teal))))
#+END_SRC
** =org-sticky-header=
#+begin_src elisp :results none
(use-package! org-sticky-header
  :config
  (org-sticky-header-mode +1))
#+end_src

* =org-alert=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! org-alert
  :config
  (setq org-alert-interval 300)
  (org-alert-enable))
#+end_src

Define a new alert style that focuses Emacs when a notification is middle-clicked
#+begin_src emacs-lisp :tangle yes :results none
(defun ++dunst+i3-notify (info)
  (async-start
    `(lambda ()
       ,(async-inject-variables "alert-default-icon")
       (shell-command-to-string (concat (executable-find "dunstify")
                                  (format " --action=\"forwardAction,Forward\" --appname=Emacs --icon=%s \"%s\" \"%s\" "
                                    alert-default-icon
                                    ,(plist-get info :buffer-name)
                                    ,(plist-get info :message))
                                  " | tr -d '\n'")))
    (lambda (dunstify-result)
      (when (equal dunstify-result "forwardAction")
        (async-start
          `(lambda ()
             ,(async-inject-variables "++window-id")
             (shell-command-to-string ,(format "i3-msg --socket %s [id=%s] focus"
                                         ;; See https://www.reddit.com/r/i3wm/comments/glhgo4/comment/fvntamj/?utm_source=share&utm_medium=web2x&context=3
                                         "\"/run/user/1000/i3/$(ls -t /run/user/1000/i3/ | awk '{print $1}' | grep ipc | head -n 1)\""
                                         ++window-id)))
          (lambda (i3-focus-result)
            (message "FOCUS RESULT FROM i3: %s !!!" i3-focus-result)
            (org-agenda-list)))))))

(require 'async)
(alert-define-style 'dunst+i3 :title "dunst + i3"
  :notifier
  (lambda (info)
    ;; buffer prop isn't serializable
    (plist-put info :buffer-name (buffer-name (plist-get info :buffer)))
    (plist-delete! info :buffer)
    (++dunst+i3-notify info)))
#+end_src
* =org-excalidraw=
#+begin_src elisp :results none
(use-package! org-excalidraw
  :config
  (setq org-excalidraw-directory (concat ++sync-folder-path "/excalidraw")))
(after! org (org-excalidraw-initialize))
#+end_src
* =org-habit=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! org-habit
  :config
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-show-habits-only-for-today nil
        org-habit-show-all-today nil
        org-habit-preceding-days 14
        org-habit-following-days 7))
#+end_src
* =org-roam=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! org-roam
  :config
  (defvar ++org-roam-dir "~/Dropbox/emacs/org-roam")
  (make-directory ++org-roam-dir 'parents)
  (setq org-roam-directory ++org-roam-dir)
  (org-roam-db-autosync-mode))
#+end_src
* =org-sticky-header=
#+begin_src emacs-lisp :tangle yes :results none
(use-package! org-sticky-header
  :config
  (add-hook 'org-mode-hook (lambda () (org-sticky-header-mode +1))))
#+end_src
* =persp=
#+begin_src elisp
(setq persp-save-dir (concat ++sync-folder-path "/sessions/"))
#+end_src
* =projectile=
It's convenient to open a file in a different window sometimes.
#+begin_src elisp
(map! :nv "SPC f g" #'projectile-find-file-other-window)
#+end_src

Get rid of annoying projectile staleness without it being too expensive/noticeable for local files.
For remote files, make it a bit longer
#+begin_src elisp
(defun ++set-projectile-cache-duration ()
  (setq projectile-files-cache-expire
        (if (and buffer-file-name
            (file-remote-p (file-truename buffer-file-name)))
       (* 10 60) ; Long-ish projectile cache for remote files
     10)))

(use-package! projectile
  :config
  (add-hook 'find-file-hook #'++set-projectile-cache-duration))
#+end_src
* =pulsar=
#+begin_src elisp :results none
(use-package! pulsar
  :config
  (setq pulsar-pulse-functions
        '(recenter-top-bottom
          move-to-window-line-top-bottom
          reposition-window
          forward-page
          backward-page
          scroll-up-command
          scroll-down-command
          org-next-visible-heading
          org-previous-visible-heading
          org-forward-heading-same-level
          org-backward-heading-same-level
          outline-backward-same-level
          outline-forward-same-level
          outline-next-visible-heading
          outline-previous-visible-heading
          outline-up-heading))
  (setq pulsar-pulse-on-window-change t)
  (setq pulsar-pulse t)
  (setq pulsar-delay 0.05)
  (setq pulsar-iterations 10)
  (setq pulsar-face 'pulsar-magenta)
  (setq pulsar-highlight-face 'pulsar-yellow)
  (pulsar-global-mode +1)
  ;; For some reason, some commands don't work despite being in pulsar-pulse-functions
  (setq ++pulsar-pulse-line-cmds
        '(evil-scroll-up
          evil-scroll-down
          evil-goto-line
          evil-goto-last-line
          evilem-motion-previous-line
          evilem-motion-next-line))
  (defun ++pulsar-pulse-line (func)
    (advice-add func :after (lambda (_f &rest _args) (pulsar-pulse-line))))
  (mapc #'++pulsar-pulse-line ++pulsar-pulse-line-cmds)
  ;; integration with the `consult' package:
  (add-hook 'consult-after-jump-hook #'pulsar-recenter-top)
  (add-hook 'consult-after-jump-hook #'pulsar-reveal-entry)
  ;; integration with the built-in `imenu':
  (add-hook 'imenu-after-jump-hook #'pulsar-recenter-top)
  (add-hook 'imenu-after-jump-hook #'pulsar-reveal-entry))
#+end_src
* =shell=
#+begin_src elisp :results none
(use-package! shell
  :init
  (setq comint-buffer-maximum-size 8192
        comint-input-ring-size 1024
        comint-output-filter-functions (remove 'ansi-color-process-output comint-output-filter-functions))
  :config
  (defun ++shell-setup ()
    (setq-local corfu-auto nil
                line-spacing nil)
    ;; Disable font-locking in this buffer to improve performance
    (font-lock-mode -1)
    ;; Prevent font-locking from being re-enabled in this buffer
    (make-local-variable 'font-lock-function)
    (setq font-lock-function (lambda (_) nil))
    (require 'xterm-color)
    (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)
    ;; TODO This doesn't work. How do I enable modeline?
    (doom-modeline-mode 1))
  (add-hook 'shell-mode-hook #'++shell-setup)
  (remove-hook 'shell-mode-hook #'hide-mode-line-mode)
  ;; Keybinds
  (map! :map shell-mode-map
        :nvi "C-r" #'comint-history-isearch-backward
        :nvi "C-k" #'comint-previous-input
        :nvi "C-j" #'comint-next-input
        :nvi "C-l" #'comint-clear-buffer))
#+end_src
* =symex=
Best structural editing package to date
#+begin_src elisp
(use-package! symex
  :config
  (add-hook! '(clojure-mode-hook
               clojurescript-mode-hook
               clojurec-mode-hook
               emacs-lisp-mode-hook
               inferior-emacs-lisp-mode-hook
               org-mode-hook)
    (symex-mode +1)
    (symex-initialize)
    (map! :map doom-leader-map "k" (cmd! (when symex-mode (symex-mode-interface))))
    (setq symex-modal-backend 'hydra)))
#+end_src

Utilize modeline color to tell me if I'm in symex-mode
#+begin_src elisp
(defhydra+ hydra-symex (:columns 5
                        :post (progn
                                ;; TODO Avoid duplication by storing this beforehand
                                (set-face-attribute 'mode-line nil :background "#23102C")
                                (symex-exit-mode)))
  "Symex mode"
  ("C-j" symex-emit-backward "emit backward")
  ("C-h" symex-capture-backward "capture backward")
  ("C-l" symex-capture-forward "capture forward")
  ("C-k" symex-emit-forward "emit forward"))

(advice-add 'symex-mode-interface :after (lambda (&rest args)
                                           (symex-hide-menu)
                                           (set-face-attribute 'mode-line nil :background "#5a1111")))
#+end_src
* =speed-dial=
#+begin_src elisp
(use-package! speed-dial
  :config
  (speed-dial-mode +1)
  (speed-dial-apply '(("C-c 1" . "~/Dropbox/work/audience-republic/misc.el")
                      ("C-c 2" . "~/Dropbox/life/todos.org")
                      ("C-c 3" . "~/Dropbox/blog/content-org")
                      ("C-c 4" . "~/Dropbox/work/audience-republic/contracting.org")
                      ("C-c 5" . "~/work/misc.org")
                      ("C-c 6" . "~/work/misc-2.org"))))
#+end_src
* =speed-type=
#+begin_src elisp :results none
(use-package! speed-type
  :config
  (setq speed-type-default-lang 'English))
#+end_src
* =thread-dump=
#+begin_src elisp
(use-package! thread-dump)
#+end_src
* =tide=
#+begin_src elisp :results none
;; (defun setup-tide-mode ()
;;   (require 'company)
;;   (tide-setup)
;;   (eldoc-mode -1)
;;   (tide-hl-identifier-mode -1)
;;   (setq tide-completion-detailed nil
;;         tide-completion-ignore-case t
;;         tide-save-buffer-after-code-edit nil)
;;   (setq-local completion-at-point-functions
;;     (mapcar #'cape-company-to-capf
;;       (list #'company-tide)))
;;   (advice-add #'tide-eldoc-function :around #'ignore))

;; (use-package! tide
;;   :config
;;   (advice-remove 'tide-setup 'eldoc-mode)
;;   (add-hook! '(typescript-tsx-mode-hook
;;                typescript-mode-hook
;;                web-mode-hook
;;                js-mode-hook
;;                js2-mode-hook)
;;              #'setup-tide-mode))
#+end_src
* =tree-sitter=
#+begin_src elisp :results none
(use-package! tree-sitter)
(use-package! tree-sitter-langs)

(global-tree-sitter-mode)
(add-hook 'tree-sitter-after-on-hook (lambda (&rest args) (ignore-errors (tree-sitter-hl-mode +1))))
;; (tree-sitter-require 'tsx)
(add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-mode . tsx))
(add-to-list 'tree-sitter-major-mode-language-alist '(scss-mode . css))
#+end_src
* =vertico=
#+begin_src elisp :results none
(use-package! vertico
  :config
  (map! :map vertico-map
        "C-l" #'vertico-insert
        "C-;" #'vertico-exit)
  (when (display-graphic-p) ; Yabai on Mac sometimes hides posframes
    (require 'vertico-posframe)
    (vertico-multiform-mode)
    ;; Configure the display per command.
    ;; Use a buffer with indices for imenu
    ;; and a flat (Ido-like) menu for M-x.
    (setq vertico-multiform-commands
          '((execute-extended-command posframe)
            (helpful-callable posframe)
            (helpful-variable posframe)
            (find-file posframe)
            (projectile-find-file posframe)
            (doom/find-file-in-private-config posframe)
            (projectile-switch-project posframe)
            (consult-recent-file posframe)
            (consult-bookmark buffer)
            (consult-imenu buffer)
            (+default/search-buffer buffer)
            (yas-insert-snippet posframe)
            (lsp-execute-code-action posframe)))
    ;; Configure the display per completion category.
    ;; Use the grid display for files and a buffer
    ;; for the consult-grep commands.
    (setq vertico-multiform-categories
          '((consult-grep buffer)))))
#+end_src

posframe setup
#+begin_src emacs-lisp :tangle yes :results none
(use-package! vertico-posframe
  :config
  (setq vertico-posframe-border-width 1
        vertico-posframe-parameters '((left-fringe . 10)
                                      (right-fringe . 10))))
#+end_src

buffer setup
#+begin_src elisp :results none
(setq vertico-buffer-display-action '(display-buffer-in-side-window
                                       (side . right)
                                       (window-width . 0.4)))
#+end_src

* =vi-tilde-fringe=
#+begin_src elisp :results none
(setq vi-tilde-fringe-bitmap-array [#b00000000
                                    #b00000000
                                    #b00000000
                                    #b11111111
                                    #b11111111
                                    #b00000000
                                    #b00000000
                                    #b00000000])
#+end_src
* =which-key=
#+begin_src elisp
(which-key-mode +1)
#+end_src
* =whitespace=
Make trailing spaces and tabs visible
#+begin_src elisp
(use-package! whitespace
  :config
  (global-whitespace-mode)
  (setq whitespace-style '(face tabs tab-mark trailing)
        whitespace-display-mappings '((tab-mark 9 [124 9] [92 9])))
  (custom-set-faces
   '(whitespace-tab ((t (:foreground "#636363"))))))
#+end_src
* =writeroom-mode=
#+begin_src elisp
(map! :map doom-leader-map "z" #'+zen/toggle-fullscreen)
#+end_src
* =yasnippet=
#+begin_src elisp :results none
(use-package! yasnippet
  :config
  (setq yas-snippet-dirs
    '("~/.doom.d/snippets"))
  (yas-global-mode +1))
#+end_src
Auto-change mode to insert state after inserting a snippet
#+begin_src elisp :results none
(advice-add 'yas-insert-snippet :after (lambda (&rest _)
                                         (evil-insert-state)))
#+end_src
* =+lookup=
=SPC e= for eldoc
#+begin_src elisp
(map! :leader :desc "Lookup doc" :n "e" #'+lookup/documentation)
#+end_src
