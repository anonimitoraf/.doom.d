#+TITLE: Packages
#+STARTUP: overview
* =ace-window=
#+begin_src elisp
(map! :map doom-leader-map "w SPC" #'ace-select-window)
#+end_src
Make window labels very obvious
#+begin_src elisp
  (custom-set-faces!
    '(aw-leading-char-face
      :foreground "white" :background "red"
      :weight bold :height 2.5 :box (:line-width 10 :color "red")))
#+end_src
* =aggressive-indent=
Only enable aggressive-indent-mode automatically for files with LOC < threshold

NOTE: Disable aggressive-indent for now because it makes a lot of things laggy. Instead, just indent stuff manually
#+begin_src elisp
;; (use-package! aggressive-indent
;;   :config
;;   (defvar ++aggressive-indent-loc-threshold 500)
;;   (defun ++aggressive-indent-mode-setup ()
;;     (interactive)
;;     (unless (memql major-mode aggressive-indent-excluded-modes)
;;       (aggressive-indent-mode
;;        (if (< (count-lines (point-min) (point-max))
;;               ++aggressive-indent-loc-threshold)
;;            (progn (-> (format "ENABLING aggressive-index (LOC is < threshold %s)"
;;                               ++aggressive-indent-loc-threshold)
;;                       (propertize 'face '(:foreground "green"))
;;                       (message))
;;                   +1)
;;          (progn (-> (format "DISABLING aggressive-index (LOC is >= threshold %s)"
;;                             ++aggressive-indent-loc-threshold)
;;                     (propertize 'face '(:foreground "red"))
;;                     (message))
;;                 -1)))))
;;   (add-hook! '(clojure-mode-hook
;;                clojurescript-mode-hook
;;                clojurec-mode-hook
;;                lisp-mode-hook
;;                emacs-lisp-mode-hook
;;                css-mode-hook)
;;              #'++aggressive-indent-mode-setup))
#+end_src
* =alert=
#+begin_src elisp
(require 'alert)
(setq alert-default-style 'notifications
      alert-fade-time 30)
#+end_src
* =all-the-icons=
They're too big (by default) for my taste
#+begin_src elisp
(use-package! all-the-icons
  :config (setq all-the-icons-scale-factor 0.90))
#+end_src
* =avy=
This package is used for jumping around efficiently within a file. I really ought to use it more.

Searching should be done using 2 chars almost all the time hence we use a very short timeout.
#+begin_src elisp
(setq avy-timeout-seconds 0.1)
#+end_src
* =built-ins=
** bookmarks
I want to sync bookmarks across my devices.
#+begin_src elisp
(setq bookmark-default-file (concat ++sync-folder-path "/emacs/bookmarks"))
#+end_src

Save bookmarks immediately (rather than just when Emacs is killed).
#+begin_src elisp
(setq bookmark-save-flag 1)
#+end_src
** replace
#+begin_src elisp
(map! :leader
      :desc "Find-replace" "r" #'anzu-query-replace)
(map! :leader
      :desc "Find-replace (regexp)" "R" #'anzu-query-replace-regexp)
#+end_src
* =centaur-tabs=
I currently don't use tabs but if I did, well, the config's here
#+begin_src elisp
(after! centaur-tabs
  (setq centaur-tabs-style "rounded"
        centaur-tabs-height 5
        centaur-tabs-set-icons t
        centaur-tabs-set-modified-marker t
        centaur-tabs-show-navigation-buttons t
        centaur-tabs-gray-out-icons 'buffer)
  (centaur-tabs-headline-match)
  (centaur-tabs-enable-buffer-reordering)
  ;; (setq centaur-tabs-adjust-buffer-order t)
  (centaur-tabs-mode t))
#+end_src
* =cider=
#+begin_src elisp
(use-package! cider
  :config
  (setq cider-repl-pop-to-buffer-on-connect nil
        cider-dynamic-indentation nil
        cider-font-lock-dynamically nil
        cider-font-lock-reader-conditionals nil
        nrepl-force-ssh-for-remote-hosts t)
  (map! :map cider-inspector-mode-map
        :nv "C-k" #'cider-inspector-previous-inspectable-object
        :nv "C-j" #'cider-inspector-next-inspectable-object
        :nv "C-h" #'cider-inspector-pop
        :nv [mouse-3] #'cider-inspector-pop
        :nv "C-l" #'cider-inspector-operate-on-point))
#+end_src

Free up the minibuffer by not showing CIDER docs there
#+begin_src elisp
(advice-add 'cider-eldoc :around #'ignore)
#+end_src

Patch for being able to connect to multiple nREPL instances by using a random local port each time
#+begin_src elisp
(defun nrepl--ssh-tunnel-connect (host port)
  "Connect to a remote machine identified by HOST and PORT through SSH tunnel."
  (message "[nREPL] Establishing SSH tunneled connection to %s:%s ..." host port)
  (let* ((remote-dir (if host (format "/ssh:%s:" host) default-directory))
         (local-port (nrepl--random-free-local-port))
         (ssh (or (executable-find "ssh")
                  (error "[nREPL] Cannot locate 'ssh' executable")))
         (cmd (nrepl--ssh-tunnel-command ssh remote-dir port local-port))
         (tunnel-buf (nrepl-tunnel-buffer-name
                      `((:host ,host) (:port ,port))))
         (tunnel (start-process-shell-command "nrepl-tunnel" tunnel-buf cmd)))
    (process-put tunnel :waiting-for-port t)
    (set-process-filter tunnel (nrepl--ssh-tunnel-filter local-port))
    (while (and (process-live-p tunnel)
                (process-get tunnel :waiting-for-port))
      (accept-process-output nil 0.005))
    (if (not (process-live-p tunnel))
        (error "[nREPL] SSH port forwarding failed.  Check the '%s' buffer" tunnel-buf)
      (message "[nREPL] SSH port forwarding established to localhost:%s" local-port)
      (let ((endpoint (nrepl--direct-connect "localhost" local-port)))
        (thread-first endpoint
          (plist-put :tunnel tunnel)
          (plist-put :remote-host host))))))

(defun nrepl--random-free-local-port ()
  (let* ((random-free-local-port-cmd (concat "comm -23 "
                                             "<(seq 1024 65535 | sort) "
                                             "<(ss -Htan | awk '{print $4}' | cut -d':' -f2 | sort -u) | "
                                             "shuf | head -n 1")))
    (with-temp-buffer
           (insert (string-trim-right (shell-command-to-string random-free-local-port-cmd)))
           (buffer-string))))

(defun nrepl--ssh-tunnel-command (ssh dir remote-port local-port)
  "Command string to open SSH tunnel to the host associated with DIR's PORT."
  (with-parsed-tramp-file-name dir v
     ;; this abuses the -v option for ssh to get output when the port
    ;; forwarding is set up, which is used to synchronise on, so that
    ;; the port forwarding is up when we try to connect.
    (format-spec
     "%s -v -N -L %l:localhost:%p %u'%h'"
     `((?s . ,ssh)
       (?l . ,local-port)
       (?p . ,remote-port)
       (?h . ,v-host)
       (?u . ,(if v-user (format "-l '%s' " v-user) ""))))))
#+end_src
* =clipetty=
#+begin_src elisp
(use-package! clipetty
  :config
  (global-clipetty-mode +1))
#+end_src
* =company=
#+begin_src elisp
(after! company
  (setq company-idle-delay 0.05
        company-tooltip-idle-delay 0.05
        company-minimum-prefix-length 2
        company-selection-wrap-around t)
  (define-key company-active-map (kbd "C-j") 'company-select-next-or-abort)
  (define-key company-active-map (kbd "C-k") 'company-select-previous-or-abort)
  (if (display-graphic-p)
      (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
    ;; Terminal seems to work with just "TAB"
    (define-key company-active-map (kbd "TAB") 'company-complete-selection))
  (define-key company-active-map (kbd "C-l") 'company-complete-selection)
  (define-key company-mode-map (kbd "C-SPC") 'company-manual-begin))
#+end_src
Remove some conflicting keybindings with company-mode.
TODO Check if this is actually a good thing to do.
#+begin_src elisp
(define-key global-map (kbd "C-j") nil)
(define-key global-map (kbd "C-k") nil)
#+end_src
* =company-quickhelp=
#+begin_src elisp
(use-package! company-quickhelp
  :config
  (company-quickhelp-mode +1))
#+end_src
* =dap=
# dap-mode causes errors so comment it for now
# Typical templates DAP debug templates. Primarily serves as examples that can be tweaked
# #+begin_src elisp
# (use-package! dap-mode
#   :config
#   (dap-register-debug-template
#    "Typescript project (src/index.ts)"
#    (list :type "node"
#          :cwd "${workspaceFolder}"
#          :runtimeArgs ["--nolazy" "-r" "ts-node/register"]
#          :args "src/index.ts"
#          :request "launch"
#          :name "Node index.ts")))
#           #+end_src
# Disable DAP tooltips in TTY because it's glitchy
# #+begin_src elisp
# (use-package! dap-mode
#   :config
#   (dap-tooltip-mode (if (display-graphic-p) +1 -1)))
# #+end_src
# Add modeline to DAP windows (a bit hacky)
# #+begin_src elisp
# (use-package! dap-mode
#   :config
#   (add-hook '+dap-running-session-mode-hook (lambda () (doom-modeline-mode +1))))
# #+end_src
* =dotenv-mode=
#+begin_src elisp
(use-package! dotenv-mode
  :config (add-to-list 'auto-mode-alist '("\\.env\\..*" . dotenv-mode)))
#+end_src
* =edbi=
#+begin_src elisp
;; (require 'edbi)
#+end_src
* =ejc=

Make emacs into a decent SQL "IDE"
#+begin_src elisp
(require 'ejc-sql)
(require 'ejc-autocomplete)
(require 'ejc-direx)
(use-package! ejc-sql
  :config
  (setq ejc-ring-length 10000
        ejc-result-table-impl 'ejc-result-mode
        ejc-complete-on-dot t
        ejc-sql-separator "---")
  (set-popup-rules!
    '(("^database: "
       :quit nil
       :side left
       :size 75
       :select t)
      ("*ejc-sql-output*"
       :quit nil
       :side bottom
       :size 30
       :select nil)))
  (add-hook 'sql-mode-hook (lambda ()
                             (ejc-sql-mode t)
                             (map! :nv "SPC a" #'ejc-eval-user-sql-at-point)))
  (add-hook 'ejc-result-mode-hook (lambda () (visual-line-mode -1)))
  (add-hook 'ejc-sql-minor-mode-hook
            (lambda ()
              (company-mode -1)
              (auto-complete-mode +1)
              (ejc-ac-setup)
              ;; Fuzzy doesn't seem to work though. TODO Find out why
              (setq ac-use-fuzzy t
                    ac-fuzzy-enable t
                    ac-menu-height 10
                    ac-candidate-max 10
                    ac-delay 0.5
                    ac-auto-show-menu 0.5)
              (map! :map ac-completing-map
                    "C-k" #'ac-previous
                    "C-j" #'ac-next
                    "<tab>" #'ac-complete)))
  (add-hook 'ejc-sql-connected-hook (lambda ()
                                      (ejc-set-fetch-size 100)
                                      (ejc-set-max-rows 100)
                                      (ejc-set-show-too-many-rows-message t)
                                      (ejc-set-column-width-limit 50)
                                      (ejc-set-use-unicode t))))

(defun ejx-direx:make-buffer-prefixed ()
  (let ((current-ejc-db ejc-db)
        (buf (direx:ensure-buffer-for-root
              (make-instance 'ejc-direx:database
                             :name (format "database: %s" (ejc-get-db-name ejc-db))
                             :buffer (current-buffer)
                             :file-name (buffer-file-name)
                             :cache (cons nil (ejc-direx:get-structure))))))
    (with-current-buffer buf
      (setq-local ejc-db current-ejc-db))
    buf))

(defun ejx-direx:show ()
  (interactive)
  (pop-to-buffer (ejx-direx:make-buffer-prefixed)))
#+end_src
* =elcord=
Flex on Discord that we're using Emacs.
#+begin_src elisp
(defun start-elcord ()
  (interactive)
  (use-package! elcord
    :config
    (setq elcord-refresh-rate 5
          elcord-use-major-mode-as-main-icon t)
    (elcord-mode +1)
    (message "Started elcord")))

(defun stop-elcord ()
  (interactive)
  (elcord-mode -1)
  (message "Stopped elcord"))
#+end_src
* =evil=
#+begin_src elisp
(define-key evil-insert-state-map (kbd "C-j") nil)
(define-key evil-insert-state-map (kbd "C-k") nil)
(define-key evil-motion-state-map (kbd "<tab>") nil)

(define-key evil-motion-state-map (kbd "C-o") 'evil-jump-backward)
(define-key evil-motion-state-map (kbd "C-i") 'evil-jump-forward)
#+end_src

Disable the annoying auto-comment on newline.
#+begin_src elisp
(setq +evil-want-o/O-to-continue-comments nil)
#+end_src

Additionally, I like to have structural typing for s-exprs.
#+begin_src elisp
(use-package! evil-lisp-state
  :init (setq evil-lisp-state-global t)
  :config (evil-lisp-state-leader "SPC k"))
#+end_src

Unbind annoying key that I press a lot accidentally.
#+begin_src elisp
(unbind-key "K" evil-normal-state-map)
(unbind-key "K" evil-visual-state-map)
(unbind-key "K" evil-motion-state-map)
#+end_src

I've always found evil's undo to undo more than I want it to
#+begin_src elisp
(setq evil-want-fine-undo t)
#+end_src

I keep changing my mind about this, but for now, I think splitting and selecting the left and top windows feel better.
#+begin_src elisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

evil-collection with workaround for =slime= specifically (and evaluation of the last sexp)
#+begin_src elisp
(use-package! evil-collection
  :config
  (evil-collection-init)
  (setq evil-collection-setup-minibuffer t))
#+end_src
* =flycheck=
Emphasize the error/warning fringe indicators. When I go through a file, I typically rely on the fridge to tell guide me to code that I have to fix.
#+begin_src elisp
(define-fringe-bitmap 'flycheck-fringe-bitmap-beam
  (vector #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111
          #b11111111))

(flycheck-define-error-level 'error
  :severity 30
  :compilation-level 2
  :overlay-category 'flycheck-error-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-beam
  :fringe-face 'flycheck-fringe-error
  :error-list-face 'flycheck-error-list-error)

(flycheck-define-error-level 'warning
  :severity 20
  :compilation-level 2
  :overlay-category 'flycheck-warning-overlay
  :fringe-bitmap 'flycheck-fringe-bitmap-beam
  :fringe-face 'flycheck-fringe-warning
  :error-list-face 'flycheck-error-list-warning)

(setq flycheck-display-errors-delay 0.01)
#+end_src

Popup-tip customization for the terminal
#+begin_src elisp
(use-package! flycheck-popup-tip
  :config
  (setq flycheck-popup-tip-error-prefix " "))
#+end_src

Customize the flycheck errors table to have longer columns
#+begin_src elisp
(use-package! flycheck
  :config
  (setq flycheck-error-list-format
        `[("File" 32)
          ("Line" 8 flycheck-error-list-entry-<)
          ("Col" 8 nil)
          ("Level" 32 flycheck-error-list-entry-level-<)
          ("ID" 32 t)
          (#("Message (Checker)" 0 7
             (face flycheck-error-list-error-message)
             9 16
             (face flycheck-error-list-checker-name))
           0 t)]))
#+end_src

* =keychain-environment=
#+begin_src elisp
(require 'keychain-environment)
(keychain-refresh-environment)
#+end_src
* =idle-highlight-mode=
#+begin_src elisp
(add-hook 'text-mode-hook (lambda () (idle-highlight-mode +1)))
(add-hook 'prog-mode-hook (lambda () (if (bound-and-true-p lsp-mode)
                                    (idle-highlight-mode -1)
                                  (idle-highlight-mode +1))))
#+end_src
* =i3wm-config-mode=
#+begin_src elisp
(require 'i3wm-config-mode)
#+end_src
* =ielm=
Set a cool prompt and make it non-noisy (What does this even mean?)
#+begin_src elisp
(setq ielm-noisy nil
      ielm-prompt "λ> ")
#+end_src
* =itail=
#+begin_src elisp
(require 'itail)
#+end_src
* =iscroll=
#+begin_src elisp
(use-package! iscroll
  :config (iscroll-mode +1))
#+end_src
* =ispell=
Fix the ispell dictinoary.
#+begin_src elisp
(setq ispell-dictionary "en")
#+end_src
* =ivy=
Make ivy show up in the top center of the screen (apart from when used with counsel)
#+begin_src elisp
(after! ivy-posframe
  (setf (alist-get t ivy-posframe-display-functions-alist)
        #'ivy-posframe-display-at-frame-top-center)
  (setf (alist-get 'swiper ivy-posframe-display-functions-alist)
        #'ivy-posframe-display-at-frame-top-center)
  (setq ivy-posframe-border-width 10
        ivy-posframe-width 120
        ivy-posframe-parameters (append ivy-posframe-parameters '((left-fringe . 3)
                                                                  (right-fringe . 3)))))
#+end_src


TODO What is this for?
#+begin_src elisp
(setq posframe-arghandler
      (lambda (_buffer-or-name key value)
        (or (eq key :lines-truncate)
            value)))
#+end_src

Get rid of ./ and ../ in ivy file prompts
#+begin_src elisp
(setq ivy-extra-directories ())
#+end_src

Fix for https://github.com/hlissner/doom-emacs/issues/3038.
#+begin_src elisp
(after! counsel
  (setq counsel-rg-base-command "rg -M 240 --with-filename --no-heading --line-number --color never %s || true"))
#+end_src

Patch for automatically enabling `ivy-calling` in `ivy-occur-grep-mode` and make it toggle-able
#+begin_src elisp
(map! :map ivy-occur-grep-mode-map
      :n "c" (cmd! (setq ivy-calling (not ivy-calling))))

(add-hook 'ivy-occur-grep-mode-hook
          (cmd! (setq ivy-calling t)))
#+end_src
* =kubernetes=
#+begin_src elisp
(use-package kubernetes
  :ensure t
  :commands (kubernetes-overview))

(use-package kubernetes-evil
  :ensure t
  :after kubernetes)
#+end_src
* =lsp=
#+begin_src elisp
(use-package! lsp-mode
  :config
  (add-hook! '(prog-mode-hook)
    (setq lsp-completion-enable t))
  (add-hook! '(clojure-mode-hook
               clojurescript-mode-hook
               clojurec-mode-hook)
    (setq lsp-completion-enable nil))
  (set-popup-rules!
    '(("*Flycheck errors*"
       :quit nil
       :side bottom
       :size 20
       :select nil)
      ("*lsp-help*"
       :quit t
       :side left
       :size 120
       :select t
       :modeline t))))

(after! lsp-mode
  (setq lsp-lens-enable t
        lsp-log-io nil
        lsp-idle-delay 0.2
        lsp-completion-no-cache nil
        lsp-headerline-breadcrumb-enable t
        lsp-headerline-breadcrumb-enable-diagnostics nil
        lsp-completion-sort-initial-results nil
        lsp-completion-use-last-result nil
        lsp-eldoc-enable-hover nil
        lsp-lens-place-position 'end-of-line
        lsp-enable-indentation t
        lsp-signature-auto-activate t
        lsp-signature-function 'lsp-signature-posframe
        lsp-signature-posframe-params '(:poshandler posframe-poshandler-point-bottom-left-corner-upward
                                        :height 10
                                        :width 120
                                        :border-width 1
                                        :min-width 120))
  (map! :map lsp-signature-mode-map
        "C-j" #'lsp-signature-next
        "C-k" #'lsp-signature-previous))
#+end_src
Directories to ignore for specific languages
#+begin_src elisp
(after! lsp-mode
  ;; Clojure(Script)
  (dolist (to-ignore '("[/\\\\]\\.clj-kondo$"
                       "[/\\\\]\\.shadow-cljs$"
                       "[/\\\\]resources$"))
    (add-to-list 'lsp-file-watch-ignored to-ignore)))
#+end_src
** =lsp-ui=
TODO Convert the `define-key` statements to use `map!`
#+begin_src elisp
(after! lsp-ui
  (define-key lsp-ui-peek-mode-map (kbd "j") 'lsp-ui-peek--select-next)
  (define-key lsp-ui-peek-mode-map (kbd "k") 'lsp-ui-peek--select-prev)
  (define-key lsp-ui-peek-mode-map (kbd "C-k") 'lsp-ui-peek--select-prev-file)
  (define-key lsp-ui-peek-mode-map (kbd "C-j") 'lsp-ui-peek--select-next-file)
  (define-key evil-normal-state-map (kbd "g f") 'lsp-ui-peek-find-references)
  (map! :map lsp-ui-mode-map
        :nv "SPC c m" #'lsp-ui-imenu
        :nv "SPC d" #'lsp-ui-doc-glance)
  (setq lsp-ui-peek-fontify 'always
        lsp-ui-peek-list-width 100
        lsp-ui-peek-peek-height 40
        lsp-ui-peek-always-show nil

        ;; These can be brought up on-demand with SPC d
        lsp-ui-doc-enable nil
        ;; Prevents LSP peek to disappear when mouse touches it
        lsp-ui-doc-show-with-mouse nil
        lsp-ui-doc-include-signature t
        lsp-ui-doc-delay 0
        lsp-ui-doc-position (if (display-graphic-p) 'at-point 'top)
        lsp-ui-doc-max-width 120
        lsp-ui-doc-max-height 120
        lsp-ui-doc-header nil


        lsp-ui-imenu-enable t

        ;; This is just annoying, really
        lsp-ui-sideline-enable nil))
#+end_src
Display lsp-ui-peek in a childframe so that the whole screen is used despite multiple windows.

Only on GUI though since TTY doesn't support posframes :^(.

Copied from https://github.com/emacs-lsp/lsp-ui/issues/441.
#+begin_src elisp
(when (display-graphic-p)
  (defun lsp-ui-peek--peek-display (src1 src2)
    (-let* ((win-width (frame-width))
            (lsp-ui-peek-list-width (/ (frame-width) 2))
            (string (-some--> (-zip-fill "" src1 src2)
                      (--map (lsp-ui-peek--adjust win-width it) it)
                      (-map-indexed 'lsp-ui-peek--make-line it)
                      (-concat it (lsp-ui-peek--make-footer)))))
      (setq lsp-ui-peek--buffer (get-buffer-create " *lsp-peek--buffer*"))
      (posframe-show lsp-ui-peek--buffer
                     :string (mapconcat 'identity string "")
                     :min-width (frame-width)
                     :poshandler #'posframe-poshandler-frame-center)))

  (defun lsp-ui-peek--peek-destroy ()
    (when (bufferp lsp-ui-peek--buffer)
      (posframe-delete lsp-ui-peek--buffer))
    (setq lsp-ui-peek--buffer nil
          lsp-ui-peek--last-xref nil)
    (set-window-start (get-buffer-window) lsp-ui-peek--win-start))

  (advice-add #'lsp-ui-peek--peek-new :override #'lsp-ui-peek--peek-display)
  (advice-add #'lsp-ui-peek--peek-hide :override #'lsp-ui-peek--peek-destroy))
#+end_src
* =logview=
#+begin_src elisp
(require 'logview)
#+end_src
* =modeline=
#+begin_src elisp
(after! doom-modeline
  (setq doom-modeline-buffer-file-name-style nil
        doom-modeline-height 0
        doom-modeline-major-mode-icon t
        doom-modeline-major-mode-color-icon t
        doom-modeline-buffer-modification-icon t
        doom-modeline-modal-icon nil
        doom-modeline-buffer-state-icon nil
        doom-modeline-enable-word-count nil
        doom-modeline-lsp nil))
(setq org-clock-mode-line-total 'current)
(setq display-time-default-load-average nil
      display-time-24hr-format t)
#+end_src

Display clock on modeline
#+begin_src elisp
(display-time-mode +1)
#+end_src
* =nyan-mode=
#+begin_src elisp
(use-package! nyan-mode
  :config
  (setq nyan-minimum-window-width 100
        nyan-mark-modified-buffers t)
  (nyan-mode +1))
#+end_src
* =org=
#+begin_src elisp
(after! org
  (setq org-directory (concat ++sync-folder-path "/org")
        org-default-notes-file (concat org-directory "/notes/default.org")
        org-agenda-files (cl-map 'list (lambda (f) (concat org-directory "/" f))
                                 '("life"
                                   "work"
                                   "captures"
                                   "notes")))
  (setq org-agenda-span 60
        org-agenda-start-on-weekday nil
        org-agenda-start-day "-3d"
        org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-window-setup 'other-window
        org-ellipsis " ▾"
        org-export-with-section-numbers nil
        org-hide-emphasis-markers t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 0
        org-src-preserve-indentation nil
        org-startup-folded 'content
        org-cycle-separator-lines 2
        org-todo-keywords '((sequence "TODO(t)" "ONGOING(o)" "ON HOLD(h)" "|" "DONE(d)" "CANCELLED(c)")
                            (sequence "[ ](T)" "[-](O)" "[?](H)" "|" "[X](D)"))
        org-log-done 'time
        org-hide-leading-stars t
        org-superstar-headline-bullets-list '("▪")
        org-superstar-cycle-headline-bullets 1
        org-superstar-todo-bullet-alist '("▪")
        org-tags-column -120
        org-image-actual-width nil
        ;; Don't log the time a task was rescheduled or redeadlined.
        org-log-redeadline nil
        org-log-reschedule nil
        ;; Prefer rescheduling to future dates and times
        org-read-date-prefer-future 'time))
#+end_src
Refresh org-agenda after rescheduling a task
#+begin_src elisp
(defun org-agenda-refresh ()
  "Refresh all `org-agenda' buffers."
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'org-agenda-mode)
        (org-agenda-maybe-redo)))))

(defadvice org-schedule (after refresh-agenda activate)
  "Refresh org-agenda."
  (org-agenda-refresh))
#+end_src
Allow pasting images into org-mode
#+begin_src elisp
(use-package! org-download
  :config (setq org-download-method 'attach))
#+end_src
Allow drag-and-drop-ing to `dired`
#+begin_src elisp
(add-hook 'dired-mode-hook 'org-download-enable)
#+end_src
** =org-capture=
#+begin_src elisp
(after! org
  (setq org-capture-templates
        '(("t" "" entry (file "~/Dropbox/org/captures/tasks.org")
           "* TODO %?\n%U"
           :kill-buffer t)
          ("t" "Task" entry (file "~/Dropbox/org/captures/tasks.org")
           "* TODO %?\n%U"
           :kill-buffer t)
          ("e" "From emacs" entry (file "~/Dropbox/org/captures/from-emacs.org")
           "* %i\n%?"
           :empty-lines 1
           :kill-buffer t)
          ("c" "From clipboard" entry (file "~/Dropbox/org/captures/from-clipboard.org")
           "* %x\n%?"
           :empty-lines 1
           :kill-buffer t)
          ("s" "Shopping list" entry (file "~/Dropbox/org/captures/shopping-list.org")
           "* [ ] %?"
           :jump-to-captured t
           :empty-lines 1
           :kill-buffer t))))
#+end_src
** =org-babel=
NodeJS - Make sure org-babel finds `node_modules`
#+begin_src elisp
(setenv "NODE_PATH"
        (concat
         (getenv "HOME") "/org/node_modules"  ":"
         (getenv "NODE_PATH")))
#+end_src
Clojure
#+begin_src elisp
(use-package! ob-clojure
  :init (require 'cider)
  :config (setq org-babel-clojure-backend 'cider))
#+end_src
General

TODO Find out why emacs-lisp is set to nil
#+begin_src elisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . nil)
   (Clojure . t)
   (Javascript . t)))
#+end_src
* =chrome=
Keybindings
#+begin_src elisp
(use-package! chrome
  :config (setq chrome-auto-retrieve t
                ++chrome-host "127.0.0.1"
                ++chrome-port 9222))

(defun ++chrome-new-tab ()
  (interactive)
  (chrome--devtools-do
   (chrome-tab-create :host ++chrome-host
                      :port ++chrome-port
                      :session '(++chrome-port . ++chrome-host))
   "new"))

(map! :map chrome-mode-map
      :nv "l" #'chrome-visit-tab
      :nv "x" #'chrome-delete-tab
      :nv "n" #'++chrome-new-tab)
#+end_src
Auto-fetch Chrome tabs every second
#+begin_src elisp
(setq ++chrome-tabs-retriever-timer nil)
(add-hook 'window-configuration-change-hook
          (lambda ()
            (if (eq major-mode 'chrome-mode)
                ;; Start
                (when (not ++chrome-tabs-retriever-timer)
                  (setq ++chrome-tabs-retriever-timer (run-at-time nil 1 #'chrome-retrieve-tabs)))
              ;; Stop
              (when ++chrome-tabs-retriever-timer
                (cancel-timer ++chrome-tabs-retriever-timer)
                (setq ++chrome-tabs-retriever-timer nil)))))
#+end_src
* =persp=
#+begin_src elisp
(setq persp-save-dir (concat ++sync-folder-path "/emacs/sessions/"))
#+end_src
* =projectile=
It's convenient to open a file in a different window sometimes.
#+begin_src elisp
(map! :nv "SPC f g" #'projectile-find-file-other-window)
#+end_src

Get rid of annoying projectile staleness without it being too expensive/noticeable for local files.
For remote files, make it a bit longer
#+begin_src elisp
(defun ++set-projectile-cache-duration ()
  (setq projectile-files-cache-expire
        (if (and buffer-file-name
            (file-remote-p (file-truename buffer-file-name)))
       (* 10 60) ; Long-ish projectile cache for remote files
     10)))

(use-package! projectile
  :config
  (add-hook 'find-file-hook #'++set-projectile-cache-duration))
#+end_src
* =projectile-git-autofetch=
#+begin_src elisp
(use-package! projectile-git-autofetch
  :config
  (setq projectile-git-autofetch-notify nil)
  (projectile-git-autofetch-mode +1))
#+end_src
* =rainbow=
#+begin_src elisp
(add-hook! '(text-mode-hook prog-mode-hook) (cmd! (rainbow-mode +1)))
#+end_src
* =ranger=
Start ranger in full-mode and show hidden files by default
#+begin_src elisp
(use-package! ranger
  :config
  (setq ranger-override-dired 'ranger
        ranger-show-hidden t))
#+end_src
* =screenshot=
#+begin_src elisp
(use-package! screenshot)
#+end_src
* =shell=
Company mode in shell is just annoying.
#+begin_src elisp
(add-hook 'shell-mode-hook (lambda () (company-mode -1)))
#+end_src
* =slime=
#+begin_src elisp
(use-package! slime
  :config
  (map! :map slime-mode-map
        :nv "SPC d" #'slime-describe-symbol
        :nv "SPC m e e" #'slime-eval-last-expression
        :nv "SPC m '" #'slime-connect))
#+end_src
* =smooth-scrolling=
#+begin_src elisp
(require 'smooth-scrolling)
#+end_src
* =symex=
Best structural editing package to date
#+begin_src elisp
(use-package! symex
  :config
  (symex-initialize)
  (map! :map doom-leader-map "k" #'symex-mode-interface)
  (setq symex-modal-backend 'hydra))

#+end_src

Utilize modeline color to tell me if I'm in symex-mode
#+begin_src elisp
(defhydra+ hydra-symex (:columns 5
                        :post (progn
                                (custom-set-faces!
                                  ;; TODO Avoid duplication by storing this beforehand
                                  '(mode-line :background "#23102C" :height 0.9 :width condensed))
                                (symex-exit-mode)))
  "Symex mode"
  ("C-j" symex-emit-backward "emit backward")
  ("C-h" symex-capture-backward "capture backward")
  ("C-l" symex-capture-forward "capture forward")
  ("C-k" symex-emit-forward "emit forward"))

(advice-add 'symex-mode-interface :after (lambda (&rest args)
                                           (symex-hide-menu)
                                           (custom-set-faces!
                                             '(mode-line :background "#5a1111" :height 0.9 :width condensed))))
#+end_src
* =speed-dial=
#+begin_src elisp
(use-package! speed-dial
  :config
  (speed-dial-mode +1)
  (speed-dial-apply '(("C-c 1" . "~/Dropbox/work/audience-republic/misc.el")
                      ("C-c 2" . "~/Dropbox/life/todos.org")
                      ("C-c 3" . "~/Dropbox/blog/content-org"))))
#+end_src
* =thread-dump=
#+begin_src elisp
(use-package! thread-dump)
#+end_src
* =treemacs=
#+begin_src elisp
(with-eval-after-load 'treemacs-icons
  (when (display-graphic-p)
    (treemacs-resize-icons 10)))

(use-package treemacs
  :commands (treemacs)
  :bind (("<f8>" . treemacs)
         ("<f9>" . treemacs-select-window))
  :config
  (add-hook 'treemacs-mode-hook
            (lambda ()
              (when (display-graphic-p)
                (text-scale-decrease 1.5))))
  (unless (display-graphic-p)
    (treemacs-indent-guide-mode t))
  (setq treemacs-width 50
        treemacs-is-never-other-window t
        treemacs-file-event-delay 1000
        treemacs-show-cursor t
        treemacs--width-is-locked nil
        treemacs-space-between-root-nodes nil
        treemacs-filewatch-mode t
        treemacs-fringe-indicator-mode t
        treemacs-read-string-input 'from-minibuffer))
#+end_src
* =which-key=
#+begin_src elisp
(which-key-mode +1)
#+end_src
* =writeroom-mode=
#+begin_src elisp
(map! :map doom-leader-map "z" #'+zen/toggle-fullscreen)
#+end_src
* =+lookup=
=SPC e= for eldoc
#+begin_src elisp
(map! :leader :desc "Lookup doc" :n "e" #'+lookup/documentation)
#+end_src
